IMPORT pygame
IMPORT random
IMPORT os
IMPORT pymysql
IMPORT time

SET FPS TO 60
SET WIDTH TO 1920
SET HEIGHT TO 1080
SET start_time TO time.time()
SET TOTAL_SCORE TO 10000  # Set the total score required to complete the stage

SET BLACK TO (0, 0, 0)
SET WHITE TO (255, 255, 255)
SET GREEN TO (0, 255, 0)
SET RED TO (255, 0, 0)
SET YELLOW TO (255, 255, 0)

DEFINE FUNCTION start_game(stage_names, id):  # Accept user_id as an argument
    # Database connection
    SET conn TO pymysql.connect(
        host='localhost',
        user='root',
        password='',
        port=3307,
        database='sdp'
    )

    SET my_cursor TO conn.cursor()

    # Initialize the game and create window
    pygame.init()
    pygame.mixer.init()

    SET screen TO pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Counting Strike")
    SET clock TO pygame.time.Clock()

    # Load images
    SET background_img TO pygame.image.load(os.path.join("img", "background.jpeg")).convert()
    SET player_img TO pygame.image.load(os.path.join("img", "player.png")).convert()
    SET player_mini_img TO pygame.transform.scale(player_img, (25, 19))
    player_mini_img.set_colorkey(BLACK)
    pygame.display.set_icon(player_mini_img)
    SET bullet_img TO pygame.image.load(os.path.join("img", "bullet.png")).convert()
    SET rock_imgs TO [pygame.image.load(os.path.join("img", f"rock{i}.png")).convert() FOR i IN range(7)]
    SET expl_anim TO {'lg': [], 'sm': [], 'player': []}

    FOR i IN range(9):
        SET expl_img TO pygame.image.load(os.path.join("img", f"expl{i}.png")).convert()
        expl_img.set_colorkey(BLACK)
        expl_anim['lg'].append(pygame.transform.scale(expl_img, (75, 75)))
        expl_anim['sm'].append(pygame.transform.scale(expl_img, (30, 30)))
        SET player_expl_img TO pygame.image.load(os.path.join("img", f"player_expl{i}.png")).convert()
        player_expl_img.set_colorkey(BLACK)
        expl_anim['player'].append(player_expl_img)

    SET power_imgs TO {
        'shield': pygame.image.load(os.path.join("img", "shield.png")).convert(),
        'gun': pygame.image.load(os.path.join("img", "gun.png")).convert()
    }
    SET rock_images TO {
        'tiny': pygame.image.load(os.path.join("img", "rock0.png")),
        'small': [pygame.image.load(os.path.join("img", "rock1.png")), pygame.image.load(os.path.join("img", "rock2.png"))],
        'medium': [pygame.image.load(os.path.join("img", "rock3.png")), pygame.image.load(os.path.join("img", "rock4.png"))],
        'large': [pygame.image.load(os.path.join("img", "rock5.png")), pygame.image.load(os.path.join("img", "rock6.png"))]
    }

    # Load sounds
    SET shoot_sound TO pygame.mixer.Sound(os.path.join("sound", "shoot.wav"))
    SET gun_sound TO pygame.mixer.Sound(os.path.join("sound", "pow1.wav"))
    SET shield_sound TO pygame.mixer.Sound(os.path.join("sound", "pow0.wav"))
    SET die_sound TO pygame.mixer.Sound(os.path.join("sound", "rumble.ogg"))
    SET expl_sounds TO [pygame.mixer.Sound(os.path.join("sound", "expl0.wav")), pygame.mixer.Sound(os.path.join("sound", "expl1.wav"))]
    pygame.mixer.music.load(os.path.join("sound", "background.ogg"))
    pygame.mixer.music.set_volume(0.4)

    SET font_name TO os.path.join("font/Minecraft.ttf")

    DEFINE FUNCTION draw_text(surf, text, size, x, y, color=BLACK):
        SET font TO pygame.font.Font(font_name, size)
        SET text_surface TO font.render(text, True, color)
        SET text_rect TO text_surface.get_rect()
        SET text_rect.centerx TO x
        SET text_rect.top TO y
        surf.blit(text_surface, text_rect)
        RETURN text_rect

    DEFINE FUNCTION new_rock():
        SET size_category TO random.choice(['tiny', 'small', 'medium', 'large'])
        SET speed_increase TO 1 + (elapsed_time / 120)  # Adjust speed factor based on elapsed time
        SET r TO Rock(size_category, speed_increase)
        all_sprites.add(r)
        rocks.add(r)

    DEFINE FUNCTION draw_progress_bar(surf, score, total_score, x, y, width, height):
        # Calculate the progress ratio
        SET progress_ratio TO min(score / total_score, 1)  # Ensure ratio does not exceed 1

        # Draw the progress bar background
        pygame.draw.rect(surf, (128, 128, 128), (x, y, width, height))

        # Draw the progress based on the player's score
        pygame.draw.rect(surf, GREEN, (x, y, width * progress_ratio, height))

        # Draw the border
        pygame.draw.rect(surf, WHITE, (x, y, width, height), 2)

    DEFINE FUNCTION draw_health(surf, hp, x, y):
        IF hp < 0:
            SET hp TO 0
        SET BAR_LENGTH TO 100
        SET BAR_HEIGHT TO 10
        SET fill TO (hp / 100) * BAR_LENGTH
        SET outline_rect TO pygame.Rect(x, y, BAR_LENGTH, BAR_HEIGHT)
        SET fill_rect TO pygame.Rect(x, y, fill, BAR_HEIGHT)
        pygame.draw.rect(surf, RED, fill_rect)
        pygame.draw.rect(surf, WHITE, outline_rect, 2)

    DEFINE FUNCTION draw_lives(surf, lives, img, x, y):
        FOR i IN range(lives):
            SET img_rect TO img.get_rect()
            SET img_rect.x TO x + 32 * i
            SET img_rect.y TO y
            surf.blit(img, img_rect)

    DEFINE FUNCTION draw_init():
        screen.blit(background_img, (0, 0))
        draw_text(screen, stage_names, 64, WIDTH / 2, HEIGHT / 4)
        draw_text(screen, 'to move and spacebar to shoot~', 22, WIDTH / 2, HEIGHT / 2)
        draw_text(screen, 'Start the game by pressing any key', 18, WIDTH / 2, HEIGHT * 3 / 4)
        pygame.display.update()
        SET waiting TO True
        WHILE waiting:
            clock.tick(FPS)
            FOR event IN pygame.event.get():
                IF event.type EQUALS pygame.QUIT:
                    pygame.quit()
                    RETURN True
                ELSEIF event.type EQUALS pygame.KEYDOWN:
                    SET waiting TO False
                    RETURN False

    DEFINE FUNCTION ask_question():
        SET query TO f"""
            SELECT q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, 
                a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 
            FROM `stage` 
            SET WHERE `stage_name` TO %s
            ORDER BY RAND() 
            LIMIT 1
        """        
        my_cursor.execute(query,({stage_names}))

        SET result TO my_cursor.fetchone()

        IF result:
            SET questions TO result[:10]
            SET answers TO result[10:]
            SET question TO random.choice(questions)
            SET answer TO answers[questions.index(question)]
        ELSE:
            RETURN False, False
        
        draw_text(screen, question, 24, WIDTH / 2, HEIGHT / 2 - 50)
        
        SET INPUT_box TO pygame.Rect(WIDTH / 2 - 100, HEIGHT / 2, 200, 32)  # Define the text box area
        SET color_inactive TO pygame.Color('lightskyblue3')
        SET color_active TO pygame.Color('dodgerblue2')
        SET color TO color_inactive
        SET active TO False
        SET user_answer TO ""
        
        pygame.display.update()
        
        SET waiting_for_answer TO True
        WHILE waiting_for_answer:
            FOR event IN pygame.event.get():
                IF event.type EQUALS pygame.QUIT:
                    pygame.quit()
                    RETURN False, ""
                ELSEIF event.type EQUALS pygame.MOUSEBUTTONDOWN:
                    # If the user clicks on the INPUT_box, activate it.
                    IF INPUT_box.collidepoint(event.pos):
                        SET active TO not active
                    ELSE:
                        SET active TO False
                    SET color TO color_active IF active else color_inactive
                ELSEIF event.type EQUALS pygame.KEYDOWN:
                    IF active:
                        IF event.key EQUALS pygame.K_RETURN:
                            SET waiting_for_answer TO False
                        ELSEIF event.key EQUALS pygame.K_BACKSPACE:
                            SET user_answer TO user_answer[:-1]
                        ELSE:
                            user_answer += event.unicode
            
            screen.blit(background_img, (0, 0))
            draw_text(screen, question, 24, WIDTH / 2, HEIGHT / 2 - 50)

            # Render the current text.
            SET txt_surface TO pygame.font.Font(None, 24).render(user_answer, True, color)
            SET width TO max(200, txt_surface.get_width() + 10)
            SET INPUT_box.w TO width
            screen.blit(txt_surface, (INPUT_box.x + 5, INPUT_box.y + 5))
            pygame.draw.rect(screen, color, INPUT_box, 2)
            
            pygame.display.update()

        IF not user_answer.lower().strip() EQUALS answer.lower().strip():
            draw_text(screen, "Wrong!, The Correct Answer is " + answer, 24, WIDTH / 2, HEIGHT / 2 + 50, RED)
            pygame.display.update()
            pygame.time.wait(2000)  # Wait FOR 2 seconds to display the error message

        RETURN True, user_answer.lower().strip() EQUALS answer.lower().strip()

    DEFINE FUNCTION escape_message():
        SET running TO True
        WHILE running:
            screen.blit(background_img, (0, 0))

            # Draw the prompt text
            draw_text(screen, 'Quit the Game?', 74, screen.get_width() // 2, screen.get_height() // 3, BLACK)

            # Draw the Yes and No options and get their rects
            SET yes_button_rect TO draw_text(screen, 'Yes', 50, screen.get_width() // 3, screen.get_height() // 2, GREEN)
            SET no_button_rect TO draw_text(screen, 'No', 50, 2 * screen.get_width() // 3, screen.get_height() // 2, RED)

            pygame.display.update()

            FOR event IN pygame.event.get():
                IF event.type EQUALS pygame.QUIT:
                    RETURN True  # Simulate quitting the game, RETURN True

                IF event.type EQUALS pygame.MOUSEBUTTONDOWN:
                    SET mouse_pos TO pygame.mouse.get_pos()

                    IF yes_button_rect.collidepoint(mouse_pos):
                        RETURN True  # Yes is clicked, RETURN True to simulate quitting

                    IF no_button_rect.collidepoint(mouse_pos):
                        RETURN False  # No is clicked, RETURN False to continue the game
    
    DEFINE FUNCTION draw_score_page(score):
        screen.blit(background_img, (0, 0))
        draw_text(screen, f'Score: {score}', 48, WIDTH / 2, HEIGHT / 4)
        draw_text(screen, 'Game Over', 64, WIDTH / 2, HEIGHT / 3)
        draw_text(screen, 'Press R to Restart or Q back to home page', 22, WIDTH / 2, HEIGHT / 2)
        pygame.display.update()

        SET waiting TO True
        WHILE waiting:
            clock.tick(FPS)
            FOR event IN pygame.event.get():
                IF event.type EQUALS pygame.QUIT:
                    pygame.quit()
                    RETURN 'quit'
                ELSEIF event.type EQUALS pygame.KEYDOWN:
                    IF event.key EQUALS pygame.K_r:
                        RETURN 'restart'
                    ELSEIF event.key EQUALS pygame.K_q:
                        RETURN 'quit'

    DEFINE CLASS Player(pygame.sprite.Sprite):
        DEFINE FUNCTION __init__(self):
            pygame.sprite.Sprite.__init__(self)
            SET self.image TO pygame.transform.scale(player_img, (150, 88))
            self.image.set_colorkey(BLACK)
            SET self.rect TO self.image.get_rect()
            SET self.radius TO 30
            SET self.rect.centerx TO WIDTH / 2
            SET self.rect.bottom TO HEIGHT - 10
            SET self.speedx TO 8
            SET self.health TO 100
            SET self.lives TO 3
            SET self.hidden TO False
            SET self.hide_time TO 0
            SET self.gun TO 1
            SET self.gun_time TO 0

        DEFINE FUNCTION update(self):
            SET now TO pygame.time.get_ticks()
            IF self.gun > 1 and now - self.gun_time > 5000:
                self.gun -= 1
                SET self.gun_time TO now

            IF self.hidden and now - self.hide_time > 1000:
                SET self.hidden TO False
                SET self.rect.centerx TO WIDTH / 2
                SET self.rect.bottom TO HEIGHT - 10

            SET key_pressed TO pygame.key.get_pressed()
            IF key_pressed[pygame.K_RIGHT]:
                self.rect.x += self.speedx
            IF key_pressed[pygame.K_LEFT]:
                self.rect.x -= self.speedx

            IF self.rect.right > WIDTH:
                SET self.rect.right TO WIDTH
            IF self.rect.left < 0:
                SET self.rect.left TO 0

        DEFINE FUNCTION shoot(self):
            IF not self.hidden:
                IF self.gun EQUALS 1:
                    SET bullet TO Bullet(self.rect.centerx, self.rect.top)
                    all_sprites.add(bullet)
                    bullets.add(bullet)
                    shoot_sound.play()
                ELSEIF self.gun >= 2:
                    SET bullet1 TO Bullet(self.rect.left, self.rect.centery)
                    SET bullet2 TO Bullet(self.rect.right, self.rect.centery)
                    all_sprites.add(bullet1)
                    all_sprites.add(bullet2)
                    bullets.add(bullet1)
                    bullets.add(bullet2)
                    shoot_sound.play()

        DEFINE FUNCTION hide(self):
            SET self.hidden TO True
            SET self.hide_time TO pygame.time.get_ticks()
            SET self.rect.center TO (WIDTH / 2, HEIGHT + 500)

        DEFINE FUNCTION gunup(self):
            self.gun += 1
            SET self.gun_time TO pygame.time.get_ticks()

    DEFINE CLASS Rock(pygame.sprite.Sprite):
        DEFINE FUNCTION __init__(self, size_category, speed_increase=1):
            super().__init__()
            SET self.size_category TO size_category

            IF size_category EQUALS 'tiny':
                SET self.image TO rock_images['tiny']
                SET self.hit_points TO 1
                SET self.speedy TO random.randint(7, 9) * speed_increase
            ELSEIF size_category EQUALS 'small':
                SET self.image TO random.choice(rock_images['small'])
                SET self.hit_points TO 2
                SET self.speedy TO random.randint(5, 7) * speed_increase
            ELSEIF size_category EQUALS 'medium':
                SET self.image TO random.choice(rock_images['medium'])
                SET self.hit_points TO 3
                SET self.speedy TO random.randint(3, 5) * speed_increase
            ELSEIF size_category EQUALS 'large':
                SET self.image TO random.choice(rock_images['large'])
                SET self.hit_points TO 5
                SET self.speedy TO random.randint(1, 3) * speed_increase

            SET self.rect TO self.image.get_rect()
            SET self.rect.x TO random.randint(0, WIDTH - self.rect.width)
            SET self.rect.y TO random.randint(-150, -100)
            SET self.speedx TO random.randint(-2, 2)

        DEFINE FUNCTION update(self):
            self.rect.y += self.speedy
            self.rect.x += self.speedx

            # Destroy the rock IF it goes off-screen
            IF self.rect.top > HEIGHT:
                self.kill()
                new_rock()  # Replace the rock that went off-screen
            
        DEFINE FUNCTION hit(self):
            self.hit_points -= 1
            IF self.hit_points <= 0:
                self.kill()
                new_rock()  # Replace the rock that was destroyed


    DEFINE CLASS Bullet(pygame.sprite.Sprite):
        DEFINE FUNCTION __init__(self, x, y):
            pygame.sprite.Sprite.__init__(self)
            SET self.image TO bullet_img
            self.image.set_colorkey(BLACK)
            SET self.rect TO self.image.get_rect()
            SET self.rect.centerx TO x
            SET self.rect.bottom TO y
            SET self.speedy TO -10

        DEFINE FUNCTION update(self):
            self.rect.y += self.speedy
            IF self.rect.bottom < 0:
                self.kill()

    DEFINE CLASS Explosion(pygame.sprite.Sprite):
        DEFINE FUNCTION __init__(self, center, size):
            pygame.sprite.Sprite.__init__(self)
            SET self.size TO size
            SET self.image TO expl_anim[self.size][0]
            SET self.rect TO self.image.get_rect()
            SET self.rect.center TO center
            SET self.frame TO 0
            SET self.last_update TO pygame.time.get_ticks()
            SET self.frame_rate TO 50

        DEFINE FUNCTION update(self):
            SET now TO pygame.time.get_ticks()
            IF now - self.last_update > self.frame_rate:
                SET self.last_update TO now
                self.frame += 1
                IF self.frame EQUALS len(expl_anim[self.size]):
                    self.kill()
               ELSE:
                    SET self.image TO expl_anim[self.size][self.frame]
                    SET center TO self.rect.center
                    SET self.rect TO self.image.get_rect()
                    SET self.rect.center TO center

    DEFINE CLASS Power(pygame.sprite.Sprite):
        DEFINE FUNCTION __init__(self, center):
            pygame.sprite.Sprite.__init__(self)
            SET self.type TO random.choice(['shield', 'gun'])
            SET self.image TO power_imgs[self.type]
            self.image.set_colorkey(BLACK)
            SET self.rect TO self.image.get_rect()
            SET self.rect.center TO center
            SET self.speedy TO 3

        DEFINE FUNCTION update(self):
            self.rect.y += self.speedy
            IF self.rect.top > HEIGHT:
                self.kill()

    pygame.mixer.music.play(-1)

    # Main game loop
    SET show_init TO True
    SET running TO True
    SET death_expl TO None  # Initialize the variable here

    # Main game loop
    WHILE running:
        SET elapsed_time TO time.time() - start_time  # Update elapsed time

        IF show_init:
            SET close TO draw_init()
            IF close:
                break
            SET show_init TO False
            SET all_sprites TO pygame.sprite.Group()
            SET rocks TO pygame.sprite.Group()
            SET bullets TO pygame.sprite.Group()
            SET powers TO pygame.sprite.Group()
            SET player TO Player()
            all_sprites.add(player)
            FOR i IN range(15):
                new_rock()
            SET score TO 0

        clock.tick(FPS)
        # Get INPUT
        FOR event IN pygame.event.get():
            IF event.type EQUALS pygame.QUIT:
                SET running TO False
            ELSEIF event.type EQUALS pygame.KEYDOWN:
                IF event.key EQUALS pygame.K_SPACE:
                    player.shoot()
                ELSEIF event.key EQUALS pygame.K_ESCAPE:
                    IF escape_message():
                        RETURN

        # Update game
        all_sprites.update()

        # Check FOR collisions between rocks and bullets
        SET hits TO pygame.sprite.groupcollide(rocks, bullets, False, True)
        FOR rock, bullets_hit IN hits.items():
            FOR bullet IN bullets_hit:
                rock.hit()
                IF rock.hit_points <= 0:
                    random.choice(expl_sounds).play()
                    score += int(rock.radius)
                    SET expl TO Explosion(rock.rect.center, 'lg' IF rock.size_category EQUALS 'large' else 'sm')
                    all_sprites.add(expl)
                    IF random.random() > 0.9:
                        SET pow TO Power(rock.rect.center)
                        all_sprites.add(pow)
                        powers.add(pow)

        # Check IF the score has reached the limit
        IF score >= TOTAL_SCORE:
            screen.blit(background_img, (0, 0))
            draw_text(screen, "Congratulations! You've reached 9999 points!", 48, WIDTH / 2, HEIGHT / 4)
            draw_text(screen, "Press C to Continue or Q to Return to Homepage", 22, WIDTH / 2, HEIGHT / 2)
            pygame.display.update()

            SET waiting TO True
            WHILE waiting:
                clock.tick(FPS)
                FOR event IN pygame.event.get():
                    IF event.type EQUALS pygame.QUIT:
                        pygame.quit()
                        SET running TO False
                        break
                    ELSEIF event.type EQUALS pygame.KEYDOWN:
                        IF event.key EQUALS pygame.K_c:
                            SET show_init TO True
                            SET death_expl TO None  # Reset death_expl FOR a new game
                            SET waiting TO False
                        ELSEIF event.key EQUALS pygame.K_q:
                            RETURN

        # Handle collisions and other game logic here...
        SET hits TO pygame.sprite.spritecollide(player, rocks, True, pygame.sprite.collide_circle)
        FOR hit IN hits:
            new_rock()
            
            # Initial health reduction when hit by meteorite
            SET health_loss TO 20
            player.health -= health_loss
            
            # Trigger the question
            SET question_asked, correct_answer TO ask_question()
            IF question_asked:
                IF not correct_answer:
                    # Double the health loss IF the answer is wrong
                    player.health -= health_loss * 1.2
                    
                # Check IF player health is still above zero
                IF player.health <= 0:
                    player.lives -= 1
                    IF player.lives > 0:
                        SET player.health TO 100  # Reset health after losing a life
                        player.hide()
                    ELSE:
                        # Player has lost all lives, trigger game over
                        IF not death_expl:
                            SET death_expl TO Explosion(player.rect.center, 'player')
                            all_sprites.add(death_expl)
                            die_sound.play()
                            player.hide()
                            # Insert score into the database
                            SET sql TO f"UPDATE `score` SET `{stage_names}` TO %s WHERE `id` TO %s"
                            SET values TO (score, id)  # Include the id IN the values tuple
                            my_cursor.execute(sql, values)
                            conn.commit()
                            OUTPUT("Score saved to database.")
                            SET result TO draw_score_page(score)
                            IF result EQUALS 'quit':
                                conn.close()
                                RETURN
                            ELSEIF result EQUALS 'restart':
                                SET show_init TO True
                                SET death_expl TO None
                                break
                ELSE:
                    # Ensure health is capped at a minimum of 0
                    SET player.health TO max(player.health, 0)

            # Check IF health drops to 0
            IF player.health <= 0:
                IF not death_expl:  # Prevent the death_expl from being created multiple times
                    SET death_expl TO Explosion(player.rect.center, 'player')
                    all_sprites.add(death_expl)
                    die_sound.play()
                    player.lives -= 1
                    SET player.health TO 100
                    player.hide()
                    IF player.lives <= 0:
                        # Insert score into the database
                        SET sql TO f"UPDATE `score` SET `{stage_names}` TO %s WHERE `id` TO %s"
                        SET values TO (score, id)
                        my_cursor.execute(sql, values)
                        conn.commit()
                        OUTPUT("Score saved to database.")
                        SET result TO draw_score_page(score)
                        IF result EQUALS 'quit':
                            conn.close()
                            pygame.quit()
                            RETURN
                        ELSEIF result EQUALS 'restart':
                            SET show_init TO True
                            SET death_expl TO None  # Reset death_expl FOR a new game

        SET hits TO pygame.sprite.spritecollide(player, powers, True)
        FOR hit IN hits:
            IF hit.type EQUALS 'shield':
                player.health += 20
                IF player.health > 100:
                    SET player.health TO 100
                shield_sound.play()
            ELSEIF hit.type EQUALS 'gun':
                player.gunup()
                gun_sound.play()

        IF player.lives EQUALS 0 and not (death_expl and death_expl.alive()):
            SET result TO draw_score_page(score)

            # Insert score into the database
            SET sql TO f"UPDATE `score` SET `{stage_names}` TO %s WHERE `id` TO %s"
            SET values TO (score, id)  # Include the id IN the values tuple
            
            my_cursor.execute(sql, values)
            conn.commit()
            OUTPUT("Score saved to database.")
            

            IF result EQUALS 'quit':
                # Close the connection
                conn.close()
                RETURN
            ELSEIF result EQUALS 'restart':
                SET show_init TO True
                SET death_expl TO None  # Reset death_expl FOR a new game

        # Draw/display
        screen.fill(BLACK)
        screen.blit(background_img, (0, 0))
        all_sprites.draw(screen)
        draw_text(screen, str(score), 18, WIDTH / 2, 10)
        draw_health(screen, player.health, WIDTH - 250, HEIGHT - 40)
        draw_lives(screen, player.lives, player_mini_img, WIDTH - 250, HEIGHT - 80)

        # Center the progress bar horizontally and place it at the middle vertically
        SET progress_bar_width TO 1000
        SET progress_bar_height TO 20
        SET progress_bar_x TO WIDTH / 2 - progress_bar_width / 2
        SET progress_bar_y TO HEIGHT / 30  # Adjust this value IF you want it higher or lower

        # Draw the progress bar
        draw_progress_bar(screen, score, TOTAL_SCORE, progress_bar_x, progress_bar_y, progress_bar_width, progress_bar_height)

        pygame.display.update()


    my_cursor.close()
    conn.close()
    pygame.quit()